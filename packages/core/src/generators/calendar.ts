import { ArgumentError, DateTime } from '@rschedule/core';

import {
  CollectionIterator,
  ICollectionsArgs,
  IOccurrencesArgs,
  IRunArgs,
  OccurrenceGenerator,
  OccurrenceGeneratorRunResult,
  OccurrenceIterator,
} from './occurrence-generator';

import { AddOperator } from './operators/AddOperator';

export interface ICalendarArgs<D = any> {
  schedules?: ReadonlyArray<OccurrenceGenerator> | OccurrenceGenerator;
  data?: D;
  timezone?: string | null;
  maxDuration?: number;
}

export class Calendar<Data = any> extends OccurrenceGenerator {
  readonly schedules: ReadonlyArray<OccurrenceGenerator> = [];

  /**
   * Convenience property for holding arbitrary data. Accessible on individual DateAdapters
   * generated by this `Calendar` object via the `DateAdapter#generators` property. Unlike
   * the rest of the `Calendar` object, the data property is mutable.
   */
  data: Data;

  readonly isInfinite: boolean;
  readonly hasDuration: boolean;

  constructor(args: ICalendarArgs<Data> = {}) {
    super(args);

    this.data = args.data as Data;

    if (args.schedules) {
      this.schedules = Array.isArray(args.schedules) ? args.schedules : [args.schedules];
      this.schedules = this.schedules.map(schedule => schedule.set('timezone', this.timezone));
    }

    this.isInfinite = this.schedules.some(schedule => schedule.isInfinite);
    this.hasDuration = this.schedules.every(schedule => schedule.hasDuration);
  }

  occurrences(args: IOccurrencesArgs = {}): OccurrenceIterator<[this, ...OccurrenceGenerator[]]> {
    return new OccurrenceIterator(this, this.normalizeOccurrencesArgs(args));
  }

  collections(args: ICollectionsArgs = {}): CollectionIterator<[this, ...OccurrenceGenerator[]]> {
    return new CollectionIterator(this, this.normalizeCollectionsArgs(args));
  }

  set(
    prop: 'timezone',
    value: string | null,
    options?: { keepLocalTime?: boolean },
  ): Calendar<Data>;
  set(
    prop: 'schedules',
    value: ReadonlyArray<OccurrenceGenerator> | OccurrenceGenerator,
  ): Calendar<Data>;
  set(
    prop: 'timezone' | 'schedules',
    value: ReadonlyArray<OccurrenceGenerator> | OccurrenceGenerator | string | null,
    options?: { keepLocalTime?: boolean },
  ) {
    if (prop === 'timezone') {
      return new Calendar({
        schedules: this.schedules.map(schedule =>
          schedule.set(
            prop,
            value as string | null,
            options as { keepLocalTime?: boolean } | undefined,
          ),
        ),
        data: this.data,
        timezone: value as string | null,
        maxDuration: this.maxDuration,
      });
    } else if (prop === 'schedules') {
      return new Calendar({
        schedules: Array.isArray(value)
          ? (value as OccurrenceGenerator[])
          : [value as OccurrenceGenerator],
        data: this.data,
        timezone: this.timezone,
        maxDuration: this.maxDuration,
      });
    }

    throw new ArgumentError('Unknown value for `prop`: ' + `"${prop}"`);
  }

  *_run(args: IRunArgs = {}): OccurrenceGeneratorRunResult {
    if (this.schedules.length === 0) return;

    const count = args.take;

    delete args.take;

    let iterator: OccurrenceGeneratorRunResult;

    if (this.schedules.length === 1) {
      iterator = this.schedules[0]._run(args);
    } else {
      iterator = new AddOperator(this.schedules, {
        timezone: this.timezone,
      })._run(args);
    }

    let date = iterator.next().value;
    let index = 0;

    while (date && (count === undefined || count > index)) {
      date = date.add(this, 'generator');

      const yieldArgs = yield this.normalizeRunOutput(date);

      date = iterator.next(yieldArgs).value;

      index++;
    }

    return undefined;
  }
}
