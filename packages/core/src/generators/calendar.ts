import { ArgumentError } from '@rschedule/core';

import {
  CollectionIterator,
  ICollectionsArgs,
  IOccurrencesArgs,
  IRunArgs,
  OccurrenceGenerator,
  OccurrenceGeneratorRunResult,
  OccurrenceIterator,
} from './occurrence-generator';

import { AddOperator } from './operators/AddOperator';

export interface ICalendarArgs<D = any> {
  schedules?: ReadonlyArray<OccurrenceGenerator> | OccurrenceGenerator;
  data?: D;
  timezone?: string | null;
  maxDuration?: number;
}

export class Calendar<Data = any> extends OccurrenceGenerator {
  readonly schedules: ReadonlyArray<OccurrenceGenerator> = [];

  /**
   * Convenience property for holding arbitrary data. Accessible on individual DateAdapters
   * generated by this `Calendar` object via the `DateAdapter#generators` property. Unlike
   * the rest of the `Calendar` object, the data property is mutable.
   */
  data: Data;

  readonly isInfinite: boolean;
  readonly hasDuration: boolean;

  /**
   *
   * Create a new Calendar object with the specified options.
   *
   * ### Options
   *
   * - **timezone**: The timezone that yielded occurrences should be *displayed* in.
   *   Note, this one affects the *displayed* timezone of yielded occurrences.
   *   For rules, occurrences are first found using the unmodified rule
   *   config (including whatever timezone the `start` datetime is defined
   *   in), and then converted to the timezone specified here before being
   *   yielded. By default, the timezone is *local* time (`null`). So if you don't
   *   want your rules to be displayed in local time, you must supply a
   *   timezone argument.
   * - **data**: arbitrary data you can associate with this Calendar. This
   *   is the only mutable property of `Calendar` objects.
   * - **maxDuration**: currently unused.
   * - **schedules**: either an occurrence generator, or an array of occurrence generators, which should
   *   be used to build up this Calendar's occurrences. The Calendar will display the union of occurrences
   *   its schedules produce.
   *
   */
  constructor(args: ICalendarArgs<Data> = {}) {
    super(args);

    this.data = args.data as Data;

    if (args.schedules) {
      this.schedules = Array.isArray(args.schedules) ? args.schedules : [args.schedules];
      this.schedules = this.schedules.map(schedule => schedule.set('timezone', this.timezone));
    }

    this.isInfinite = this.schedules.some(schedule => schedule.isInfinite);
    this.hasDuration = this.schedules.every(schedule => schedule.hasDuration);
  }

  occurrences(args: IOccurrencesArgs = {}): OccurrenceIterator<[this, ...OccurrenceGenerator[]]> {
    return new OccurrenceIterator(this, this.normalizeOccurrencesArgs(args));
  }

  collections(args: ICollectionsArgs = {}): CollectionIterator<[this, ...OccurrenceGenerator[]]> {
    return new CollectionIterator(this, this.normalizeCollectionsArgs(args));
  }

  set(
    prop: 'timezone',
    value: string | null,
    options?: { keepLocalTime?: boolean },
  ): Calendar<Data>;
  set(
    prop: 'schedules',
    value: ReadonlyArray<OccurrenceGenerator> | OccurrenceGenerator,
  ): Calendar<Data>;
  set(
    prop: 'timezone' | 'schedules',
    value: ReadonlyArray<OccurrenceGenerator> | OccurrenceGenerator | string | null,
    options?: { keepLocalTime?: boolean },
  ) {
    if (prop === 'timezone') {
      return new Calendar({
        schedules: this.schedules.map(schedule =>
          schedule.set(
            prop,
            value as string | null,
            options as { keepLocalTime?: boolean } | undefined,
          ),
        ),
        data: this.data,
        timezone: value as string | null,
        maxDuration: this.maxDuration,
      });
    } else if (prop === 'schedules') {
      return new Calendar({
        schedules: Array.isArray(value)
          ? (value as OccurrenceGenerator[])
          : [value as OccurrenceGenerator],
        data: this.data,
        timezone: this.timezone,
        maxDuration: this.maxDuration,
      });
    }

    throw new ArgumentError('Unknown value for `prop`: ' + `"${prop}"`);
  }

  *_run(args: IRunArgs = {}): OccurrenceGeneratorRunResult {
    if (this.schedules.length === 0) return;

    const count = args.take;

    delete args.take;

    let iterator: OccurrenceGeneratorRunResult;

    if (this.schedules.length === 1) {
      iterator = this.schedules[0]._run(args);
    } else {
      iterator = new AddOperator(this.schedules, {
        timezone: this.timezone,
      })._run(args);
    }

    let date = iterator.next().value;
    let index = 0;

    while (date && (count === undefined || count > index)) {
      date = date.add(this, 'generator');

      const yieldArgs = yield this.normalizeRunOutput(date);

      date = iterator.next(yieldArgs).value;

      index++;
    }

    return undefined;
  }
}
